
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>modOpt.constraints.iNpartial &#8212; modOpt 18.03.2019 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '18.03.2019',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for modOpt.constraints.iNpartial</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">***************************************************</span>
<span class="sd">Import packages</span>
<span class="sd">***************************************************</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">mpmath</span>
<span class="kn">import</span> <span class="nn">itertools</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;doIntervalNesting&#39;</span>
        <span class="p">]</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">***************************************************</span>
<span class="sd">Algorithm for complete interval nesting procedure</span>
<span class="sd">***************************************************</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="doIntervalNesting"><a class="viewcode-back" href="../../../modOpt/modOpt.constraints.html#modOpt.constraints.iNpartial.doIntervalNesting">[docs]</a><span class="k">def</span> <span class="nf">doIntervalNesting</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; iterates the state variable intervals related to model using the</span>
<span class="sd">    Gauss-Seidel Operator combined with an interval nesting strategy</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        model           object of class model</span>
<span class="sd">        dict_options    dictionary with solver options</span>
<span class="sd">    </span>
<span class="sd">    Return:</span>
<span class="sd">        model           model object with reduced state variable bounds</span>
<span class="sd">        iterNo          number of iteration steps in Newton algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">iterNo</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">xBounds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getXBounds</span><span class="p">()</span>
    <span class="n">xSymbolic</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getXSymbolic</span><span class="p">()</span>
    <span class="n">parameter</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getParameter</span><span class="p">()</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">blocks</span>
    <span class="n">newModel</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">dimVar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">boundsAlmostEqual</span> <span class="o">=</span> <span class="kc">False</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dimVar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;iterMaxNewton&quot;</span><span class="p">]):</span> 
        
        <span class="n">iterNo</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">newXBounds</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)):</span> <span class="c1">#TODO: Parallelizing</span>
            
            <span class="n">xAlmostEqual</span> <span class="o">=</span> <span class="kc">False</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xBounds</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">FsymPerm</span><span class="p">,</span> <span class="n">xSymbolicPerm</span><span class="p">,</span> <span class="n">xBoundsPerm</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">getBoundsOfPermutedModel</span><span class="p">(</span><span class="n">xBounds</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> 
                                                                                  <span class="n">xSymbolic</span><span class="p">,</span> 
                                                                                  <span class="n">parameter</span><span class="p">)</span>
            
            <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getPrecision</span><span class="p">(</span><span class="n">xBoundsPerm</span><span class="p">)</span>
            <span class="n">intervalsPerm</span><span class="p">,</span> <span class="n">boundsAlmostEqual</span> <span class="o">=</span> <span class="n">reduceXBounds</span><span class="p">(</span><span class="n">xBoundsPerm</span><span class="p">,</span> <span class="n">xSymbolicPerm</span><span class="p">,</span> <span class="n">FsymPerm</span><span class="p">,</span>
                                                             <span class="n">blocks</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">boundsAlmostEqual</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">intervalsPerm</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">break</span>
            
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">intervalsPerm</span><span class="p">)):</span> <span class="c1">#TODO: Parallelizing and in new Function</span>
                
                <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dimVar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>     
                <span class="n">x</span><span class="p">[</span><span class="n">newModel</span><span class="o">.</span><span class="n">colPerm</span><span class="p">]</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">intervalsPerm</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>           
                <span class="n">newXBounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">checkWidths</span><span class="p">(</span><span class="n">xBounds</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;machEpsRelNewton&quot;</span><span class="p">],</span> 
                               <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;machEpsAbsNewton&quot;</span><span class="p">]):</span> 
                    <span class="n">xAlmostEqual</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
    
            <span class="k">if</span> <span class="n">xAlmostEqual</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">newModel</span><span class="o">.</span><span class="n">setXBounds</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">newModel</span><span class="p">,</span> <span class="n">iterNo</span>
          
        <span class="k">if</span> <span class="n">newXBounds</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="n">xBounds</span> <span class="o">=</span> <span class="n">newXBounds</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="nb">print</span> <span class="s2">&quot;NoSolutionError: No valid solution space was found. Please check consistency of initial constraints&quot;</span>
            
    <span class="n">newModel</span><span class="o">.</span><span class="n">setXBounds</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">newModel</span><span class="p">,</span> <span class="n">iterNo</span></div>


<span class="k">def</span> <span class="nf">getPrecision</span><span class="p">(</span><span class="n">xBounds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculates precision for intervalnesting procedure (when intervals are</span>
<span class="sd">    joined to one interval)</span>
<span class="sd">    Args:</span>
<span class="sd">        xBounds         list with iteration variable bounds in mpmath.mpi formate</span>
<span class="sd">    </span>
<span class="sd">    Return:</span>
<span class="sd">        precision as float value</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">allValuesOfx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xBounds</span><span class="p">:</span>
        <span class="n">allValuesOfx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">a</span><span class="p">))))</span>
        <span class="n">allValuesOfx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">b</span><span class="p">))))</span>
    
    <span class="n">minValue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">allValuesOfx</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">5</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">minValue</span><span class="p">))</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reduceXBounds</span><span class="p">(</span><span class="n">xBounds</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">boundsAlmostEqual</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Solves an equation system blockwise. For block dimensions &gt; 1 each </span>
<span class="sd">    iteration variable interval of the block is reduced sequentially by all </span>
<span class="sd">    equations of the block. The narrowest bounds from this procedure are taken</span>
<span class="sd">    over.</span>
<span class="sd">     </span>
<span class="sd">        Args: </span>
<span class="sd">            xBounds:            One set of variable interavls as numpy array</span>
<span class="sd">            xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">            f:                  list with symbolic equation system in sympy logic</span>
<span class="sd">            blocks:             List with blocklists, whereas the blocklists contain</span>
<span class="sd">                                the block elements with index after permutation</span>
<span class="sd">            dict_options:       dictionary with solving settings</span>
<span class="sd">            boundsAlmostEqual:  boolean list, dimension equals number of variables.</span>
<span class="sd">                                if variable bounds can&#39;t be further reduced, the</span>
<span class="sd">                                variable entry in the list equals true. The variable</span>
<span class="sd">                                order is given by the global index.</span>
<span class="sd">        Returns:                list with new set of variable bounds</span>
<span class="sd">                        </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="n">xNewBounds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">absEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolX&quot;</span><span class="p">]</span>
    
    
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)):</span>
        <span class="n">blockDim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">blockDim</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span> 
            <span class="n">j</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">boundsAlmostEqual</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> 
                <span class="n">xNewBounds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">xNewBounds</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="k">continue</span>           
            <span class="k">if</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;Debug-Modus&quot;</span><span class="p">]:</span> <span class="nb">print</span> <span class="n">j</span>
            
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">blockDim</span><span class="p">):</span> <span class="c1">#TODO: Parallelizing</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">m</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">xSymbolic</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    
                    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="p">[]:</span> <span class="n">y</span> <span class="o">=</span> <span class="n">reduceXIntervalByFunction</span><span class="p">(</span><span class="n">xBounds</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> 
                           <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="n">y</span> <span class="o">=</span> <span class="n">reduceTwoIVSets</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">reduceXIntervalByFunction</span><span class="p">(</span><span class="n">xBounds</span><span class="p">,</span> 
                                                    <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">))</span>
                        <span class="c1">#if y == []: return [], boundsAlmostEqual</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">!=</span> <span class="p">[[]]:</span> <span class="n">xNewBounds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[],</span> <span class="n">boundsAlmostEqual</span>
            <span class="c1">#else: xNewBounds[j] =[xBounds[j]], boundsAlmostEqual</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xNewBounds</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="n">boundsAlmostEqual</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">checkVariableBound</span><span class="p">(</span><span class="n">xNewBounds</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">xNewBounds</span><span class="p">)),</span> <span class="n">boundsAlmostEqual</span>


<span class="k">def</span> <span class="nf">checkVariableBound</span><span class="p">(</span><span class="n">newXInterval</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; if lower and upper bound of a variable are almost equal the boolean </span>
<span class="sd">    boundsAlmostEqual is set to true.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        newXInterval:       variable interval in mpmath.mpi logic</span>
<span class="sd">        relEpsX:            relative variable interval tolerance</span>
<span class="sd">        absEpsX:            absolute variable interval tolerance</span>
<span class="sd">        </span>
<span class="sd">    Returns:                True, if lower and upper variable bound are almost</span>
<span class="sd">                            equal.</span>
<span class="sd">       </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">newXInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">newXInterval</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">reduceXIntervalByFunction</span><span class="p">(</span><span class="n">xBounds</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span> <span class="c1"># One function that gets fi, xi and does the procedure</span>
    <span class="sd">&quot;&quot;&quot; reduces variable interval by either solving a linear function directly</span>
<span class="sd">    with Gauss-Seidl-Operator or finding the reduced variable interval(s) of a</span>
<span class="sd">    nonlinear function by interval nesting</span>
<span class="sd">     </span>
<span class="sd">        Args: </span>
<span class="sd">            xBounds:            One set of variable interavls as numpy array</span>
<span class="sd">            xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">            f:                  symbolic equation in sympy logic</span>
<span class="sd">            i:                  index for iterated variable interval</span>
<span class="sd">            dict_options:       dictionary with solving settings</span>

<span class="sd">        Returns:                list with new set of variable intervals</span>
<span class="sd">                        </span>
<span class="sd">    &quot;&quot;&quot;</span>       
    <span class="n">xBounds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">fx</span><span class="p">,</span> <span class="n">fWithoutX</span> <span class="o">=</span> <span class="n">splitFunctionByVariableDependency</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    
    <span class="n">fx</span><span class="p">,</span> <span class="n">dfdX</span><span class="p">,</span> <span class="n">df2dX</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">fxInterval</span><span class="p">,</span> <span class="n">dfdxInterval</span><span class="p">,</span> <span class="n">df2dxInterval</span><span class="p">,</span> <span class="n">xBounds</span> <span class="o">=</span> <span class="n">calculateCurrentBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> 
                    <span class="n">fWithoutX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bi</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">fxInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">dfdxInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">df2dxInterval</span> <span class="o">==</span> <span class="p">[]:</span> 
        <span class="k">return</span> <span class="p">[</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">df2dxInterval</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">fxInterval</span> <span class="o">==</span> <span class="n">dfdxInterval</span><span class="o">*</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span> <span class="c1"># Linear Case -&gt; solving system directly</span>
        <span class="k">return</span> <span class="n">getReducedIntervalOfLinearFunction</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span>
             
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Nonlinear Case -&gt; solving system by interval nesting</span>
        <span class="k">return</span> <span class="n">getReducedIntervalOfNonlinearFunction</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">dfdX</span><span class="p">,</span> <span class="n">df2dX</span><span class="p">,</span> <span class="n">dfdxInterval</span><span class="p">,</span> 
                            <span class="n">df2dxInterval</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">splitFunctionByVariableDependency</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;a sympy function expression f is splitted into a sum from x depended terms</span>
<span class="sd">    and a sum from x independent terms. If the expressions consists of a product or</span>
<span class="sd">    quotient, it is only checked if this one contains x or not. If one or both of the</span>
<span class="sd">    resulting parts are empty they are returned as 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        f:              mathematical expression in sympy logic</span>
<span class="sd">        x:              symbolic variable x</span>
<span class="sd">        </span>
<span class="sd">        Return:</span>
<span class="sd">            fvar:           sum of x dependent arguments</span>
<span class="sd">            fWithoutVar:    sum of x independent arguments</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">allArguments</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span>
    <span class="n">allArgumentsWithVariable</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">allArgumentsWithoutVariable</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#if allArguments == ():</span>
    <span class="c1">#    if x in f.free_symbols: return f, 0</span>
    <span class="c1">#    else: return 0, f</span>
        
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">class_key</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;Add&#39;</span><span class="p">:</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">allArguments</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="n">allArgumentsWithVariable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">allArgumentsWithoutVariable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
             
        <span class="n">fvar</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">allArgumentsWithVariable</span><span class="p">)</span>
        <span class="n">fWithoutVar</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">allArgumentsWithoutVariable</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fvar</span><span class="p">,</span> <span class="n">fWithoutVar</span>
    
    <span class="c1">#if f.func.class_key()[2]==&#39;Mul&#39;:</span>
    <span class="c1">#    if x in f.free_symbols: return f, 0</span>
    <span class="c1">#    else: return 0, f</span>

    <span class="k">else</span><span class="p">:</span> 
        <span class="nb">print</span> <span class="s2">&quot;Problems occured during function parsing&quot;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">lambdifyToMpmathIv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converting operations of symoblic equation system f (simpy) to </span>
<span class="sd">    arithmetic interval functions (mpmath.iv)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">mpmathIv</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;exp&quot;</span> <span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">iv</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span>
            <span class="s2">&quot;sin&quot;</span> <span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">iv</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span>
            <span class="s2">&quot;cos&quot;</span> <span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">iv</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span>
            <span class="s2">&quot;log&quot;</span> <span class="p">:</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">iv</span><span class="o">.</span><span class="n">log</span><span class="p">}</span>
    
    <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">f</span><span class="p">,</span> <span class="n">mpmathIv</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">calculateCurrentBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">fWithoutX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; calculates bounds of function fx, the residual fWithoutX, first and second</span>
<span class="sd">    derrivative of function fx with respect to variable xSymbolic[i] (dfX, df2dX).</span>
<span class="sd">    It uses the tolerance values from dict_options in the complex case to remove </span>
<span class="sd">    complex intervals by interval nesting.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fx:                 symbolic function in sympy logic (contains current </span>
<span class="sd">                            iteration variable X)</span>
<span class="sd">        fWithoutX:          symbolic function in sympy logic (does not contain </span>
<span class="sd">                            current iteration variable X)                            </span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        i:                  index of current iteration variable</span>
<span class="sd">        xBounds:            numpy array with variable bounds</span>
<span class="sd">        dict_options:       dictionary with entries about stop-tolerances</span>

<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        dfdX:               first derrivative of function fx with respect to </span>
<span class="sd">                            variable xSymbolic[i] in mpmath.mpi-logic</span>
<span class="sd">        df2dX:              second derrivative of function fx with respect to </span>
<span class="sd">                            variable xSymbolic[i] in mpmath.mpi-logic</span>
<span class="sd">        bi:                 residual interval in mpmath.mpi logic</span>
<span class="sd">        fxInterval:         function interval in mpmath.mpi logic</span>
<span class="sd">        dfdxInterval:       Interval of first derrivative in mpmath.mpi logic </span>
<span class="sd">        df2dxInterval:      Interval of second derrivative in mpmath.mpi logic </span>
<span class="sd">        xBounds:            real set of variable intervals in mpmath.mpi logic </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#TODO: Parallelizing and Output       </span>
    <span class="n">dfdX</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
    <span class="n">df2dX</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
    
    <span class="n">fxBounds</span> <span class="o">=</span> <span class="n">lambdifyToMpmathIv</span><span class="p">(</span><span class="n">xSymbolic</span><span class="p">,</span> <span class="n">fx</span><span class="p">)</span>
    <span class="n">dfdxBounds</span> <span class="o">=</span> <span class="n">lambdifyToMpmathIv</span><span class="p">(</span><span class="n">xSymbolic</span><span class="p">,</span> <span class="n">dfdX</span><span class="p">)</span>
    <span class="n">df2dxBounds</span> <span class="o">=</span> <span class="n">lambdifyToMpmathIv</span><span class="p">(</span><span class="n">xSymbolic</span><span class="p">,</span> <span class="n">df2dX</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">bi</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="o">-</span><span class="n">fWithoutX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="n">fWithoutX</span> <span class="o">=</span> <span class="n">reformulateComplexExpressions</span><span class="p">(</span><span class="n">fWithoutX</span><span class="p">)</span>
        <span class="k">try</span> <span class="p">:</span> <span class="n">bi</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="o">-</span><span class="n">fWithoutX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="n">fxBounds</span><span class="p">,</span> <span class="n">dfdxBounds</span><span class="p">,</span> <span class="n">df2dxBounds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">xBounds</span>
      
    <span class="k">try</span><span class="p">:</span>
       <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>
        
    <span class="k">except</span><span class="p">:</span>
        <span class="n">newXBounds</span> <span class="o">=</span> <span class="n">reactOnComplexError</span><span class="p">(</span><span class="n">fxBounds</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newXBounds</span> <span class="o">==</span> <span class="p">[]:</span> 
            <span class="k">return</span> <span class="n">fxBounds</span><span class="p">,</span> <span class="n">dfdxBounds</span><span class="p">,</span> <span class="n">df2dxBounds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">xBounds</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newXBounds</span>
            <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>
      
    <span class="k">try</span><span class="p">:</span>
       <span class="n">dfdxInterval</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>
        
    <span class="k">except</span><span class="p">:</span>
        <span class="n">newXBounds</span> <span class="o">=</span> <span class="n">reactOnComplexError</span><span class="p">(</span><span class="n">dfdxBounds</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newXBounds</span> <span class="o">==</span> <span class="p">[]:</span> 
            <span class="k">return</span> <span class="n">fxBounds</span><span class="p">,</span> <span class="n">dfdxBounds</span><span class="p">,</span> <span class="n">df2dxBounds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">xBounds</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newXBounds</span>
            <span class="n">dfdxInterval</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>            
 
    <span class="k">try</span><span class="p">:</span>    
        <span class="n">df2dxInterval</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">df2dX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>
        
    <span class="k">except</span><span class="p">:</span>
        <span class="n">newXBounds</span> <span class="o">=</span> <span class="n">reactOnComplexError</span><span class="p">(</span><span class="n">df2dxBounds</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newXBounds</span> <span class="o">==</span> <span class="p">[]:</span> 
            <span class="k">return</span> <span class="n">fxBounds</span><span class="p">,</span> <span class="n">dfdxBounds</span><span class="p">,</span> <span class="n">df2dxBounds</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="n">xBounds</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newXBounds</span>
            <span class="n">dfdxInterval</span> <span class="o">=</span> <span class="n">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fxBounds</span><span class="p">,</span> <span class="n">dfdxBounds</span><span class="p">,</span> <span class="n">df2dxBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">fxInterval</span><span class="p">,</span> <span class="n">dfdxInterval</span><span class="p">,</span> <span class="n">df2dxInterval</span><span class="p">,</span> <span class="n">xBounds</span>   
    
            
<span class="k">def</span> <span class="nf">getBoundsOfFunctionExpression</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; evaluates function expression f for variable bounds xBounds</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        f:                  scalar function in mpmath logic</span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        xBounds:            numpy array with variable bounds</span>

<span class="sd">        </span>
<span class="sd">    Returns: mpmath.mpi interval of function expression in xBounds</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fMpmathIV</span> <span class="o">=</span> <span class="n">lambdifyToMpmathIv</span><span class="p">(</span><span class="n">xSymbolic</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fMpmathIV</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)))</span>
            

<span class="k">def</span> <span class="nf">reformulateComplexExpressions</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; to avoid complex intervals this function reformulates arguments of log or</span>
<span class="sd">    pow functions, so that for example:</span>
<span class="sd">        </span>
<span class="sd">        log(a) = log((a**2)**0.5)</span>
<span class="sd">        b**0.25 = ((b**2)**0.5)**0.25</span>
<span class="sd">        </span>
<span class="sd">    In this way, only real numbers remain.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        f                       scalar function in sympy logic</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        f                       reformulated scalar function in sympy logic</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">allArguments</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sympy</span><span class="o">.</span><span class="n">preorder_traversal</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">allArguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">allArguments</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">class_key</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Pow&#39;</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">((</span><span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">class_key</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="p">((</span><span class="n">allArguments</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span>


<span class="k">def</span> <span class="nf">reactOnComplexError</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; starts interval nesting procedure to get rid of complex intervals</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        f:                  scalar function in mpmath logic</span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        i:                  index of current iteration variable</span>
<span class="sd">        xBounds:            numpy array with variable bounds</span>
<span class="sd">        dict_options:       dictionary with variable interval tolerances </span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        realSection:        real xBounds (so far this is only valid if there is</span>
<span class="sd">                            only one complex and one real interval, </span>
<span class="sd">                            TODO: return set of real intervals for x[i])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">absEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolX&quot;</span><span class="p">]</span> 
    <span class="n">realSection</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curXBounds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">problematicSection</span> <span class="o">=</span> <span class="p">[</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    
    <span class="k">while</span> <span class="n">problematicSection</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">curProblematicSection</span> <span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">problematicSection</span><span class="p">)):</span>
            
            <span class="n">curXBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">problematicSection</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">a</span>
            <span class="n">complexA</span> <span class="o">=</span> <span class="n">testOneBoundOnComplexity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">curXBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">curXBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">problematicSection</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">mid</span>
            <span class="n">complexMid</span> <span class="o">=</span> <span class="n">testOneBoundOnComplexity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">curXBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">curXBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">problematicSection</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">b</span>
            <span class="n">complexB</span> <span class="o">=</span> <span class="n">testOneBoundOnComplexity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">curXBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    
            <span class="n">problematicInterval</span><span class="p">,</span> <span class="n">realInterval</span> <span class="o">=</span> <span class="n">complexOperator</span><span class="p">(</span><span class="n">complexA</span><span class="p">,</span> <span class="n">complexMid</span><span class="p">,</span> <span class="n">complexB</span><span class="p">,</span>
                                                        <span class="n">problematicSection</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">problematicInterval</span> <span class="o">!=</span> <span class="p">[]:</span> 
                <span class="k">if</span> <span class="n">curProblematicSection</span> <span class="o">==</span> <span class="p">[]:</span> <span class="n">curProblematicSection</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">problematicInterval</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">problematicInterval</span><span class="p">,</span> <span class="n">curProblematicSection</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">realInterval</span> <span class="o">!=</span><span class="p">[]:</span>
                <span class="k">if</span> <span class="n">realSection</span> <span class="o">==</span> <span class="p">[]:</span> <span class="n">realSection</span> <span class="o">=</span> <span class="n">realInterval</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="n">realSection</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">realInterval</span><span class="p">,</span> <span class="n">realSection</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
                    
        <span class="n">problematicSection</span> <span class="o">=</span> <span class="n">checkAbsoluteTolerance</span><span class="p">(</span><span class="n">removeListInList</span><span class="p">(</span><span class="n">curProblematicSection</span><span class="p">),</span> <span class="n">absEpsX</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">realSection</span> <span class="o">==</span><span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">realSection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">checkAbsoluteTolerance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks if width of intervals is smaller than a given relative tolerance relEpsX</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        interval:           set of intervals in mpmath.mpi-logic</span>
<span class="sd">        absEpsX:             absolute x tolerance</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        reducedInterval:    set of intervals with a higher width than absEps</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">reducedInterval</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">absEpsX</span><span class="p">:</span>
                <span class="n">reducedInterval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                
    <span class="k">return</span> <span class="n">reducedInterval</span>

<span class="k">def</span> <span class="nf">testOneBoundOnComplexity</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns False if the evlauation of f fails, assumption is that this is</span>
<span class="sd">    due to complex variable intervals</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        f:                  scalar function in mpmath logic</span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        xBounds:            numpy array with variable bounds</span>
<span class="sd">        i:                  index of current iteration variable</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        True:               Complex number</span>
<span class="sd">        False:              Real number</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)))</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    

<span class="k">def</span> <span class="nf">complexOperator</span><span class="p">(</span><span class="n">complexA</span><span class="p">,</span> <span class="n">complexMid</span><span class="p">,</span> <span class="n">complexB</span><span class="p">,</span> <span class="n">xInterval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; splits xInterval into complex/real-xInterval and real-xInterval </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        complexA:           boolean: True = complex lower bound of xInterval</span>
<span class="sd">                            False = real lower bound of xInterval</span>
<span class="sd">        complexB:           boolean: True = complex upper bound of xInterval</span>
<span class="sd">                            False = real upper bound of xInterval</span>
<span class="sd">        complexC:           boolean: True = complex midpoint of xInterval</span>
<span class="sd">                            False = real midpoint of xInterval</span>
<span class="sd">        xInterval:          interval of variable x in mpmath.mpi logic</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        list1:              list with complex-real-xInterval</span>
<span class="sd">        list2:              list with real xInterval</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">complexA</span> <span class="ow">and</span> <span class="n">complexMid</span> <span class="ow">and</span> <span class="n">complexB</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">complexA</span> <span class="ow">and</span> <span class="n">complexMid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complexB</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">xInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">,</span> <span class="n">xInterval</span><span class="o">.</span><span class="n">b</span><span class="p">)],</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">complexA</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complexMid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complexB</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">xInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">xInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">)],</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">xInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">,</span> <span class="n">xInterval</span><span class="o">.</span><span class="n">b</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complexA</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complexMid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complexB</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span> <span class="c1"># non monotone function</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complexA</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">complexMid</span> <span class="ow">and</span> <span class="n">complexB</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">xInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">,</span> <span class="n">xInterval</span><span class="o">.</span><span class="n">b</span><span class="p">)],</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">xInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">xInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complexA</span> <span class="ow">and</span> <span class="n">complexMid</span> <span class="ow">and</span> <span class="n">complexB</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">xInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">xInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">)],</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">getReducedIntervalOfLinearFunction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;returns reduced interval of variable X if f is linear in X. The equation</span>
<span class="sd">    is solved directly by the use of the gaussSeidelOperator.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        a:                  first symbolic derivative of function f with respect to x</span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        i:                  integer with current iteration variable index</span>
<span class="sd">        xBounds:            numpy array with set of variable bounds</span>
<span class="sd">        bi:                 current function residual bounds</span>
<span class="sd">    </span>
<span class="sd">    Returns:                reduced x-Interval(s)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">aInterval</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)))</span>
    
    <span class="n">checkAndRemoveComplexPart</span><span class="p">(</span><span class="n">aInterval</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">bi</span> <span class="o">-</span> <span class="n">aInterval</span> <span class="o">*</span> <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span> <span class="c1"># if this is the case, there is no solution in xBoundsi</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">bi</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">aInterval</span><span class="p">):</span>  <span class="c1"># if this is the case, bi/aInterval would return [-inf, +inf]. Hence the approximation of x is already smaller</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">gaussSeidelOperator</span><span class="p">(</span><span class="n">aInterval</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1"># bi/aInterval  </span>


<span class="k">def</span> <span class="nf">checkAndRemoveComplexPart</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a warning if a complex interval occurs and keeps only the real</span>
<span class="sd">    part.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interval</span><span class="o">.</span><span class="n">imag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s2">&quot;Warning: A complex interval: &quot;</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span><span class="s2">&quot; occured.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;For further calculations only the real part: &quot;</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="s2">&quot; is used.&quot;</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">real</span>
        

<span class="k">def</span> <span class="nf">gaussSeidelOperator</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Computation of the Gauss-Seidel-Operator [1] to get interval for x</span>
<span class="sd">    for given intervals for a and b from the 1-dimensional linear system:</span>
<span class="sd">     </span>
<span class="sd">                                    a * x = b</span>
<span class="sd">        Args: </span>
<span class="sd">            a:     interval of mpi format from mpmath library </span>
<span class="sd">            b:     interval of mpi format from mpmath library</span>
<span class="sd">            x:     interval of mpi format from mpmath library </span>
<span class="sd">                    (initially guessed interval of x)</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            interval:   interval(s) of mpi format from mpmath library where</span>
<span class="sd">                        solution for x can be in, if interval remains [] there</span>
<span class="sd">                        is no solution within the initially guessed interval of x</span>
<span class="sd">                        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">interval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">ivDivision</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">ivIntersection</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intersection</span> <span class="o">!=</span><span class="p">[]:</span> <span class="n">interval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">interval</span>
    

<span class="k">def</span> <span class="nf">ivDivision</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the result of the divion of two intervals i1, i2: i1 / i2</span>
<span class="sd">    </span>
<span class="sd">        Args: </span>
<span class="sd">            i1:     interval of mpi format from mpmath library</span>
<span class="sd">            i2:     interval of mpi format from mpmath library </span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            mpmath.mpi(a,b):    resulting interval of division [a,b], </span>
<span class="sd">                                this is empty if i2 =[0,0] and returns []</span>
<span class="sd">                                </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Different cases:</span>
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">i2</span><span class="p">)</span><span class="o">==</span> <span class="kc">False</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">i1</span> <span class="o">*</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">i2</span><span class="o">.</span><span class="n">a</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">i1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">i2</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">i1</span> <span class="o">/</span> <span class="n">i2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">),</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;inf&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;inf&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">,</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span>
    
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">i1</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>    


<span class="k">def</span> <span class="nf">ivIntersection</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns intersection of two intervals i1 and i2</span>
<span class="sd">    </span>
<span class="sd">        Args: </span>
<span class="sd">            i1:     interval of mpi format from mpmath library</span>
<span class="sd">            i2:     interval of mpi format from mpmath library </span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            mpmath.mpi(a,b):    interval of intersection [a,b], </span>
<span class="sd">                                if empty [] is returned</span>
<span class="sd">                                </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
    <span class="c1"># Different cases:    </span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="ow">and</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">i2</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="n">i2</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="n">i1</span>
    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">a</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">.</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span> <span class="ow">and</span> <span class="n">i1</span><span class="o">.</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">:</span> <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">i1</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">i2</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">getReducedIntervalOfNonlinearFunction</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">dfdX</span><span class="p">,</span> <span class="n">df2dX</span><span class="p">,</span> <span class="n">dfdXInterval</span><span class="p">,</span> <span class="n">df2dxInterval</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Checks function for monotone sections in x and reduces them one after the other.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        fx:                 symbolic x-depending part of function f in mpmath.mpi logic</span>
<span class="sd">        dfdX:               first symbolic derivative of function f with respect to x</span>
<span class="sd">                            in mpmath.mpi logic</span>
<span class="sd">        dfdX:               second symbolic derivative of function f with respect to x</span>
<span class="sd">                            in mpmath.mpi logic</span>
<span class="sd">        dfdXInterval:       first derivative of function f with respect to x at xBounds</span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        i:                  integer with current iteration variable index</span>
<span class="sd">        xBounds:            numpy array with set of variable bounds</span>
<span class="sd">        bi:                 current function residual bounds</span>
<span class="sd">        dict_options:       for function and variable interval tolerances in the used</span>
<span class="sd">                            algorithms</span>

<span class="sd">    Returns:                reduced x-Interval(s) and list of monotone x-intervals</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orgXiBounds</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">dfdXInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">df2dxInterval</span> <span class="o">==</span> <span class="p">[]):</span> <span class="k">return</span> <span class="p">[</span><span class="n">orgXiBounds</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dfdXInterval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">df2dxInterval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">df2dxInterval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            
            <span class="n">incrZoneIndf2dX</span><span class="p">,</span> <span class="n">decrZoneIndf2dX</span> <span class="o">=</span> <span class="n">getContinuousFunctionSections</span><span class="p">(</span><span class="n">df2dX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
            <span class="n">increasingZone</span> <span class="o">=</span> <span class="n">removeListInList</span><span class="p">([</span><span class="n">incrZoneIndf2dX</span><span class="p">,</span> <span class="n">decrZoneIndf2dX</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">increasingZone</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[</span><span class="n">orgXiBounds</span><span class="p">]</span>
            
            <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">reduceMonotoneIntervals</span><span class="p">(</span><span class="n">increasingZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> 
                                    <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">increasing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>    
            <span class="k">return</span> <span class="n">reducedIntervals</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">monotoneIncresingIntervalNesting</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)]</span>

    
    <span class="k">if</span> <span class="p">(</span><span class="n">dfdXInterval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">df2dxInterval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">df2dxInterval</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            
            <span class="n">incrZoneIndf2dX</span><span class="p">,</span> <span class="n">decrZoneIndf2dX</span> <span class="o">=</span> <span class="n">getContinuousFunctionSections</span><span class="p">(</span><span class="n">df2dX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
            <span class="n">decreasingZone</span> <span class="o">=</span> <span class="n">removeListInList</span><span class="p">([</span><span class="n">incrZoneIndf2dX</span><span class="p">,</span> <span class="n">decrZoneIndf2dX</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">decreasingZone</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[</span><span class="n">orgXiBounds</span><span class="p">]</span>
            
            <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">reduceMonotoneIntervals</span><span class="p">(</span><span class="n">decreasingZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> 
                                    <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">increasing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>    
            <span class="k">return</span> <span class="n">reducedIntervals</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">monotoneDecreasingIntervalNesting</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">increasingZone</span><span class="p">,</span> <span class="n">decreasingZone</span><span class="p">,</span> <span class="n">nonMonotoneZone</span> <span class="o">=</span> <span class="n">getMonotoneFunctionSections</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> 
                                                                                      <span class="n">dict_options</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">increasingZone</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">decreasingZone</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">nonMonotoneZone</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[</span><span class="n">orgXiBounds</span><span class="p">]</span>
        
        <span class="c1"># TODO: non-continuous functions  </span>
        
        <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">reduceMonotoneIntervals</span><span class="p">(</span><span class="n">increasingZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> 
                                 <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">increasing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">reduceMonotoneIntervals</span><span class="p">(</span><span class="n">decreasingZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> 
                                 <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">increasing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nonMonotoneZone</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">reduceNonMonotoneIntervals</span><span class="p">(</span><span class="n">nonMonotoneZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> 
                                                          <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> 
                                                          <span class="n">dict_options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reducedIntervals</span>

    
<span class="k">def</span> <span class="nf">getContinuousFunctionSections</span><span class="p">(</span><span class="n">df2dx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;seperate variable interval into variable interval sets where a function</span>
<span class="sd">    with derivative dfdx is monontoneous</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        df2dx:               scalar second derivate of function in mpmath.mpi logic</span>
<span class="sd">        xSymbolic:           symbolic variables in derivative function</span>
<span class="sd">        i:                   index of differential variable</span>
<span class="sd">        xBounds:             numpy array with variable bounds</span>
<span class="sd">        dict_options:        dictionary with variable and function interval tolerances</span>
<span class="sd">    </span>
<span class="sd">    Return:</span>
<span class="sd">        monIncreasingZone:   monotone increasing intervals </span>
<span class="sd">        monDecreasingZone:   monotone decreasing intervals </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">relEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolF&quot;</span><span class="p">]</span>
    <span class="n">absEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolF&quot;</span><span class="p">]</span>

    <span class="n">lmax</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;NoOfNonChangingValues&quot;</span><span class="p">]</span> 
        
    <span class="n">monIncreasingZone</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">interval</span> <span class="o">=</span> <span class="p">[</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
    <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">interval</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">lmax</span><span class="p">:</span>
        
        <span class="n">curIntervals</span> <span class="o">=</span> <span class="p">[]</span>
               
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)):</span>
 
            <span class="n">newIntervals</span><span class="p">,</span> <span class="n">newMonIncreasingZone</span><span class="p">,</span> <span class="n">newMonDecreasingZone</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">testIntervalOnMonotony</span><span class="p">(</span><span class="n">df2dx</span><span class="p">,</span> <span class="n">interval</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> 
                                                                                                 <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>
                                                                                                 <span class="n">relEpsF</span><span class="p">,</span> <span class="n">absEpsF</span><span class="p">)</span>
                        
            <span class="n">monIncreasingZone</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">newMonIncreasingZone</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>            
            <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">newMonDecreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
            <span class="n">addIntervalToNonMonotoneZone</span><span class="p">(</span><span class="n">newIntervals</span><span class="p">,</span> <span class="n">curIntervals</span><span class="p">)</span>    
               
        <span class="n">interval</span> <span class="o">=</span> <span class="n">checkTolerance</span><span class="p">(</span><span class="n">removeListInList</span><span class="p">(</span><span class="n">curIntervals</span><span class="p">),</span> <span class="n">relEpsX</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span>


<span class="k">def</span> <span class="nf">removeListInList</span><span class="p">(</span><span class="n">listInList</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Changes list with the shape: [[a], [b,c], [d], ...] to [a, b, c, d, ...]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">newList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">listInList</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">listInList</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
            <span class="n">newList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listInList</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">newList</span>


<span class="k">def</span> <span class="nf">reduceMonotoneIntervals</span><span class="p">(</span><span class="n">monotoneZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> 
                                      <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">,</span> <span class="n">increasing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;reduces interval sets of one variable by interval nesting</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        monotoneZone        list with monotone increasing or decreasing set of intervals</span>
<span class="sd">        reducedIntervals    list with already reduced set of intervals</span>
<span class="sd">        fx:                 symbolic x-depending part of function f</span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        xBounds:            numpy array with set of variable bounds</span>
<span class="sd">        i:                  integer with current iteration variable index        </span>
<span class="sd">        bi:                 current function residual bounds</span>
<span class="sd">        dict_options:       dictionary with function and variable interval tolerances</span>
<span class="sd">        increasing:         boolean, True for increasing function intervals, </span>
<span class="sd">                            False for decreasing intervals</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">monotoneZone</span><span class="p">)):</span> <span class="c1">#TODO: Parallelizing</span>
        <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">monotoneZone</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> 
        
        <span class="k">if</span> <span class="n">increasing</span><span class="p">:</span> <span class="n">curReducedInterval</span> <span class="o">=</span> <span class="n">monotoneIncresingIntervalNesting</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
                <span class="c1"># TODO: add noncontinuous block for several monotone intervals</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">curReducedInterval</span> <span class="o">=</span> <span class="n">monotoneDecreasingIntervalNesting</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">curReducedInterval</span> <span class="o">!=</span><span class="p">[]</span> <span class="ow">and</span> <span class="n">reducedIntervals</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">reducedIntervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curReducedInterval</span><span class="p">)</span>
            <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">joinIntervalSet</span><span class="p">(</span><span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">curReducedInterval</span> <span class="o">!=</span><span class="p">[]:</span> <span class="n">reducedIntervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curReducedInterval</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">reducedIntervals</span>


<span class="k">def</span> <span class="nf">monotoneIncresingIntervalNesting</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; reduces variable intervals of monotone increasing functions fx</span>
<span class="sd">    by by interval nesting</span>
<span class="sd">     </span>
<span class="sd">        Args: </span>
<span class="sd">            fx:                 symbolic xi-depending part of function fi</span>
<span class="sd">            xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">            xBounds:            numpy array with set of variable bounds</span>
<span class="sd">            i:                  integer with current iteration variable index</span>
<span class="sd">            bi:                 current function residual bounds</span>
<span class="sd">            dict_options:       dictionary with function and variable interval tolerances</span>

<span class="sd">        Returns:                list with one entry that is the reduced interval </span>
<span class="sd">                                of the variable with the index i</span>
<span class="sd">                        </span>
<span class="sd">    &quot;&quot;&quot;</span>  
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">absEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolX&quot;</span><span class="p">]</span>
    <span class="n">relEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolF&quot;</span><span class="p">]</span>
    <span class="n">absEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolF&quot;</span><span class="p">]</span>
    
    
    <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">fx</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">curInterval</span> <span class="o">=</span> <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">ivIntersection</span><span class="p">(</span><span class="n">fxInterval</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span><span class="o">==</span><span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1"># first check if xBounds can be further reduced:</span>
    <span class="k">if</span> <span class="n">fxInterval</span> <span class="ow">in</span> <span class="n">bi</span><span class="p">:</span> <span class="k">return</span> <span class="n">curInterval</span>
        
    <span class="c1"># Otherwise, iterate each bound of bi:</span>
    <span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span> <span class="o">=</span> <span class="n">getFIntervalsFromXBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="c1">#if fIntervalxLow.b &gt; bi.b:</span>
        
    <span class="k">if</span> <span class="n">fIntervalxLow</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">bi</span><span class="o">.</span><span class="n">a</span><span class="p">:</span>   
         <span class="k">while</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">fxInterval</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">bi</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> 
                                   <span class="n">relEpsF</span><span class="p">,</span> <span class="n">absEpsF</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">curInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> 
                                                 <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
                         <span class="n">curInterval</span><span class="p">,</span> <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">iteratefBound</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> 
                                                <span class="n">increasing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                                <span class="n">lowerXBound</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">curInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">fxInterval</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
        
    <span class="n">lowerBound</span> <span class="o">=</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">a</span>
    <span class="n">curInterval</span>  <span class="o">=</span> <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    
    
    <span class="c1">#if fIntervalxUp.a &lt; bi.a: return []</span>
    <span class="k">if</span> <span class="n">fIntervalxUp</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">bi</span><span class="o">.</span><span class="n">b</span><span class="p">:</span>
        
        <span class="k">while</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">fxInterval</span><span class="o">.</span><span class="n">b</span><span class="p">),</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">bi</span><span class="o">.</span><span class="n">b</span><span class="p">),</span> 
                                  <span class="n">relEpsF</span><span class="p">,</span> <span class="n">absEpsF</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">curInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> 
                                                <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
            
            <span class="n">curInterval</span><span class="p">,</span> <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">iteratefBound</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> 
                                                <span class="n">increasing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                                                <span class="n">lowerXBound</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">fxInterval</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
            
    <span class="n">upperBound</span> <span class="o">=</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span>                 
    <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">lowerBound</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">monotoneDecreasingIntervalNesting</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; reduces variable intervals of monotone decreasing functions fx</span>
<span class="sd">    by by interval nesting</span>
<span class="sd">     </span>
<span class="sd">        Args: </span>
<span class="sd">            fx:                 symbolic xi-depending part of function fi</span>
<span class="sd">            xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">            xBounds:            numpy array with set of variable bounds</span>
<span class="sd">            i:                  integer with current iteration variable index</span>
<span class="sd">            bi:                 current function residual bounds</span>
<span class="sd">            dict_options:       dictionary with function and variable interval tolerances</span>
<span class="sd">            </span>
<span class="sd">        Returns:                list with one entry that is the reduced interval </span>
<span class="sd">                                of the variable with the index i</span>
<span class="sd">                        </span>
<span class="sd">    &quot;&quot;&quot;</span>     
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">absEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolX&quot;</span><span class="p">]</span>
    <span class="n">relEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolF&quot;</span><span class="p">]</span>
    <span class="n">absEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolF&quot;</span><span class="p">]</span>
    
    <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">fx</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">curInterval</span> <span class="o">=</span> <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">ivIntersection</span><span class="p">(</span><span class="n">fxInterval</span><span class="p">,</span> <span class="n">bi</span><span class="p">)</span><span class="o">==</span><span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
    
    <span class="c1"># first check if xBounds can be further reduced:</span>
    <span class="k">if</span> <span class="n">fxInterval</span> <span class="ow">in</span> <span class="n">bi</span><span class="p">:</span> <span class="k">return</span> <span class="n">curInterval</span>
    
    <span class="c1"># Otherwise, iterate each bound of bi:</span>
    <span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span> <span class="o">=</span> <span class="n">getFIntervalsFromXBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    
    <span class="c1">#if fIntervalxLow.a &lt; bi.a: return []</span>
    
    <span class="k">if</span> <span class="n">fIntervalxLow</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">bi</span><span class="o">.</span><span class="n">b</span><span class="p">:</span>   
         <span class="k">while</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">fxInterval</span><span class="o">.</span><span class="n">b</span><span class="p">),</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">bi</span><span class="o">.</span><span class="n">b</span><span class="p">),</span> 
                                   <span class="n">relEpsF</span><span class="p">,</span> <span class="n">absEpsF</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">curInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> 
                                                 <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
                         <span class="n">curInterval</span><span class="p">,</span> <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">iteratefBound</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> 
                                                <span class="n">increasing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                                <span class="n">lowerXBound</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">curInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">fxInterval</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
        
    <span class="n">lowerBound</span> <span class="o">=</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">a</span>  
    <span class="n">curInterval</span>  <span class="o">=</span> <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>        
    <span class="c1">#if fIntervalxUp.b &gt; bi.b: return []</span>
    <span class="k">if</span> <span class="n">fIntervalxUp</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">bi</span><span class="o">.</span><span class="n">a</span><span class="p">:</span>
        
        <span class="k">while</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">fxInterval</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">bi</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> 
                                  <span class="n">relEpsF</span><span class="p">,</span> <span class="n">absEpsF</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">curInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> 
                                                <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
            
            <span class="n">curInterval</span><span class="p">,</span> <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">iteratefBound</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> 
                                                <span class="n">increasing</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                                <span class="n">lowerXBound</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curInterval</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">fxInterval</span> <span class="o">==</span> <span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
                
    <span class="n">upperBound</span> <span class="o">=</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span>               
    <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">lowerBound</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iteratefBound</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">lowerXBound</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns the half of curInterval that contains the lower or upper</span>
<span class="sd">    bound of bi (biLimit)</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fx:                 symbolic xi-depending part of function fi</span>
<span class="sd">        curInterval:        X-Interval that contains the solution to f(x) = biLimit</span>
<span class="sd">        xBounds:            numpy array with set of variable bounds</span>
<span class="sd">        i:                  integer with current iteration variable index</span>
<span class="sd">        bi:                 current function residual </span>
<span class="sd">        increasing:         boolean: True = function is monotone increasing, </span>
<span class="sd">                            False = function is monotone decreasing</span>
<span class="sd">        lowerXBound:        boolean: True = lower Bound is iterated</span>
<span class="sd">                            False = upper bound is iterated</span>
<span class="sd">        </span>
<span class="sd">    Returns:    </span>
<span class="sd">        reduced curInterval (by half) and bounds of in curInterval</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="n">biBound</span> <span class="o">=</span> <span class="n">residualBoundOperator</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">lowerXBound</span><span class="p">)</span>
    
    <span class="n">curlowerXInterval</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">curInterval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">)</span>  
    <span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span> <span class="o">=</span> <span class="n">getFIntervalsFromXBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curlowerXInterval</span><span class="p">,</span> 
                                                           <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    
    <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">fBoundsOperator</span><span class="p">(</span><span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">lowerXBound</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">biBound</span> <span class="ow">in</span> <span class="n">fxInterval</span><span class="p">:</span> <span class="k">return</span> <span class="n">curlowerXInterval</span><span class="p">,</span> <span class="n">fxInterval</span>
                
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curUpperXInterval</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">curInterval</span><span class="o">.</span><span class="n">mid</span><span class="p">,</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span> <span class="o">=</span> <span class="n">getFIntervalsFromXBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curUpperXInterval</span><span class="p">,</span> 
                                                               <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        
        <span class="n">fxInterval</span> <span class="o">=</span> <span class="n">fBoundsOperator</span><span class="p">(</span><span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">lowerXBound</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">biBound</span> <span class="ow">in</span> <span class="n">fxInterval</span><span class="p">:</span> <span class="k">return</span> <span class="n">curUpperXInterval</span><span class="p">,</span> <span class="n">fxInterval</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">getFIntervalsFromXBounds</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">curInterval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns function interval for lower variable bound and upper variable </span>
<span class="sd">    bound of variable interval curInterval.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fx:             symbolic function in mpmath.mpi logic</span>
<span class="sd">        curInterval:    current variable interval in mpmath logic</span>
<span class="sd">        xBounds:        set of variable intervals in mpmath logic</span>
<span class="sd">        i:              index of currently iterated variable interval</span>
<span class="sd">                         </span>
<span class="sd">    Returns: function interval for lower variable bound and upper variable bound</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">curXBoundsLow</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">curXBoundsUp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    
    <span class="n">curXBoundsLow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">a</span>
    <span class="n">curXBoundsUp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curInterval</span><span class="o">.</span><span class="n">b</span>
        
    <span class="k">return</span> <span class="n">fx</span><span class="p">(</span><span class="o">*</span><span class="n">curXBoundsLow</span><span class="p">),</span> <span class="n">fx</span><span class="p">(</span><span class="o">*</span><span class="n">curXBoundsUp</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fBoundsOperator</span><span class="p">(</span><span class="n">fIntervalxLow</span><span class="p">,</span> <span class="n">fIntervalxUp</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">lowerXBound</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the relevant fInterval bounds for iterating the certain bi </span>
<span class="sd">    bound </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        fIntervalxLow:   function interval of lower variable bound in mpmath </span>
<span class="sd">                         logic</span>
<span class="sd">        fIntervalxUp:    function interval of upper variable bound in mpmath </span>
<span class="sd">                         logic</span>
<span class="sd">        increasing:      boolean: True = monotone increasing, False = monotone</span>
<span class="sd">                         decreasing function</span>
<span class="sd">        lowerXBound:     boolean: True = lower variable bound, False = upper </span>
<span class="sd">                         variable bound</span>
<span class="sd">                         </span>
<span class="sd">    Returns: relevant function interval for iterating bi bound in mpmath logic</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">fIntervalxLow</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">fIntervalxUp</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">fIntervalxLow</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">fIntervalxUp</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">fIntervalxUp</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">fIntervalxLow</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">fIntervalxUp</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">fIntervalxLow</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
 
    
<span class="k">def</span> <span class="nf">residualBoundOperator</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">lowerXBound</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the residual bound that is iterated in the certain case</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        bi:              function residual interval in mpmath logic</span>
<span class="sd">        increasing:      boolean: True = monotone increasing, False = monotone</span>
<span class="sd">                         decreasing function</span>
<span class="sd">        lowerXBound:     boolean: True = lower variable bound, False = upper </span>
<span class="sd">                         variable bound</span>
<span class="sd">                         </span>
<span class="sd">    Returns: lower or upper bound of function residual interval in mpmath logic</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">bi</span><span class="o">.</span><span class="n">a</span>
    <span class="k">if</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">bi</span><span class="o">.</span><span class="n">b</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">bi</span><span class="o">.</span><span class="n">b</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowerXBound</span><span class="p">:</span> <span class="k">return</span> <span class="n">bi</span><span class="o">.</span><span class="n">a</span> 


<span class="k">def</span> <span class="nf">getMonotoneFunctionSections</span><span class="p">(</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;seperate variable interval into variable interval sets where a function</span>
<span class="sd">    with derivative dfdx is monontoneous</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        dfdx:                scalar function in mpmath.mpi logic</span>
<span class="sd">        xSymbolic :          symbolic variables in derivative function</span>
<span class="sd">        i:                   index of differential variable</span>
<span class="sd">        xBounds:             numpy array with variable bounds</span>
<span class="sd">        dict_options:        dictionary with function and variable interval </span>
<span class="sd">                             tolerances</span>
<span class="sd">    </span>
<span class="sd">    Return:</span>
<span class="sd">        monIncreasingZone:   monotone increasing intervals </span>
<span class="sd">        monDecreasingZone:   monotone decreasing intervals </span>
<span class="sd">        interval:            non monotone zone if  function interval can not be</span>
<span class="sd">                             reduced to monotone increasing or decreasing section</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">absEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolX&quot;</span><span class="p">]</span>
    <span class="n">relEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolF&quot;</span><span class="p">]</span>
    <span class="n">absEpsF</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolF&quot;</span><span class="p">]</span>
    <span class="n">lmax</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;NoOfNonChangingValues&quot;</span><span class="p">]</span>     
    
    <span class="n">relEpsdFdX</span> <span class="o">=</span> <span class="n">relEpsF</span><span class="o">/</span><span class="n">relEpsX</span>
    <span class="n">absEpsdFdX</span> <span class="o">=</span> <span class="n">absEpsF</span><span class="o">/</span><span class="n">absEpsX</span>
        
    <span class="n">monIncreasingZone</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">interval</span> <span class="o">=</span> <span class="p">[</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
    
    <span class="k">while</span> <span class="n">interval</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">lmax</span><span class="p">:</span>
        
        <span class="n">curIntervals</span> <span class="o">=</span> <span class="p">[]</span>
               
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)):</span>
            <span class="n">newIntervals</span><span class="p">,</span> <span class="n">newMonIncreasingZone</span><span class="p">,</span> <span class="n">newMonDecreasingZone</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">testIntervalOnMonotony</span><span class="p">(</span><span class="n">dfdx</span><span class="p">,</span> 
                                                    <span class="n">interval</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">relEpsdFdX</span><span class="p">,</span> <span class="n">absEpsdFdX</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">newIntervals</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">checkTolerance</span><span class="p">(</span><span class="n">newIntervals</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">)</span><span class="o">==</span><span class="p">[]:</span>
                <span class="n">newIntervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="n">discretizeAndEvaluateIntervals</span><span class="p">(</span><span class="n">dfdx</span><span class="p">,</span> 
                                                    <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">newIntervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> 
                                                    <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
            
            <span class="n">monIncreasingZone</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">newMonIncreasingZone</span><span class="p">,</span> 
                                                          <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>            
            <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">newMonDecreasingZone</span><span class="p">,</span> 
                                                          <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
       
            <span class="n">addIntervalToNonMonotoneZone</span><span class="p">(</span><span class="n">newIntervals</span><span class="p">,</span> <span class="n">curIntervals</span><span class="p">)</span>
            
        <span class="n">interval</span> <span class="o">=</span> <span class="n">checkTolerance</span><span class="p">(</span><span class="n">removeListInList</span><span class="p">(</span><span class="n">curIntervals</span><span class="p">),</span> <span class="n">relEpsX</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">interval</span>


<span class="k">def</span> <span class="nf">discretizeAndEvaluateIntervals</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> 
                                   <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; if a certain interval width is undershot it is useful to discretize it and</span>
<span class="sd">    check all segments on their monotony.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        dfdX:                scalar function in mpmath.mpi logic</span>
<span class="sd">        xBounds:             numpy array with variable bounds</span>
<span class="sd">        i:                   index of differential variable</span>
<span class="sd">        intervals:           new unchecked variable intervals</span>
<span class="sd">        monIncreasingZone:   already identified monotone increasing intervals</span>
<span class="sd">        monDecreasingZone:   already identified monotone decreasing intervals </span>
<span class="sd">        dict_options:        dictionary with function and variable interval </span>
<span class="sd">                             tolerances and discretization resolution</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        newIntervals:        non monotone intervals if  function interval can not be</span>
<span class="sd">                             reduced to monotone increasing or decreasing section</span>
<span class="sd">        monIncreasingZone:   monotone increasing intervals </span>
<span class="sd">        monDecreasingZone:   monotone decreasing intervals </span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">newIntervals</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
        <span class="n">newIntervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="n">discretizeAndEvaluataInterval</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> 
                                        <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">newIntervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> 
                                        <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">newIntervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span>  
        

<span class="k">def</span> <span class="nf">discretizeAndEvaluataInterval</span><span class="p">(</span><span class="n">dfdX</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">newIntervals</span><span class="p">,</span>
                                   <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; if a certain interval width is undershot it is useful to discretize it and</span>
<span class="sd">    check all segments on their monotony.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        dfdX:                scalar function in mpmath.mpi logic</span>
<span class="sd">        xBounds:             numpy array with variable bounds</span>
<span class="sd">        i:                   index of differential variable</span>
<span class="sd">        interval:            unchecked variable interval</span>
<span class="sd">        newIntervals:        already identified non monotone intervals </span>
<span class="sd">        monIncreasingZone:   already identified monotone increasing intervals</span>
<span class="sd">        monDecreasingZone:   already identified monotone decreasing intervals </span>
<span class="sd">        dict_options:        dictionary with function and variable interval </span>
<span class="sd">                             tolerances and discretization resolution</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        newIntervals:        non monotone intervals if  function interval can not be</span>
<span class="sd">                             reduced to monotone increasing or decreasing section</span>
<span class="sd">        monIncreasingZone:   monotone increasing intervals </span>
<span class="sd">        monDecreasingZone:   monotone decreasing intervals </span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span>
    
    <span class="n">intervalBounds</span> <span class="o">=</span> <span class="n">convertIntervalBoundsToFloatValues</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="n">intervalPoints</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">intervalBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">intervalBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resolution</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intervalPoints</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
        
        <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">intervalPoints</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">intervalPoints</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> 
               <span class="nb">max</span><span class="p">(</span><span class="n">intervalPoints</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">intervalPoints</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="n">dfdX</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">monIncreasingZone</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">([</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">dfdX</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">monDecreasingZone</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">([</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">monDecreasingZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">newIntervals</span> <span class="o">=</span> <span class="n">addIntervaltoMonotoneZone</span><span class="p">([</span><span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">newIntervals</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">newIntervals</span><span class="p">,</span> <span class="n">monIncreasingZone</span><span class="p">,</span> <span class="n">monDecreasingZone</span>
  
          
<span class="k">def</span> <span class="nf">convertIntervalBoundsToFloatValues</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; converts mpmath.mpi intervals to list with bounds as float values</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        interval                interval in math.mpi logic</span>
<span class="sd">        </span>
<span class="sd">    Returns:                    list with bounds as float values</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">a</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">b</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">testIntervalOnMonotony</span><span class="p">(</span><span class="n">dfdx</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">relEpsdFdX</span><span class="p">,</span> <span class="n">absEpsdFdX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;splits interval into 2 halfs and orders concering their monotony </span>
<span class="sd">    behaviour of f (first derivative dfdx):</span>
<span class="sd">        1. monotone increasing function in interval of x </span>
<span class="sd">        2. monotone decreasing function in interval of x</span>
<span class="sd">        3. non monotone function in interval of x</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        dfdx:           scalar derivative of f with respect to x in mpmath.mpi-logic</span>
<span class="sd">        interval:       x interval in mpmath.mpi-logic</span>
<span class="sd">        xBounds:        numpy array with variable bounds in mpmath.mpi-logic</span>
<span class="sd">        i:              variable index</span>
<span class="sd">        l:              counts [-inf,inf] dfdxIntervals to filter out functions</span>
<span class="sd">                        that have an x indepenendent derrivate constant interval of </span>
<span class="sd">                        [-inf, +inf] for example: f=x/y-1 and y in [-1,1]</span>
<span class="sd">        relEpsdFdX:     relative tolerance of first derivative</span>
<span class="sd">        absEpsdFdX:     absolute tolerance of first derivative</span>
<span class="sd">    Reutrn:</span>
<span class="sd">        3 lists nonMonotoneZone, monotoneIncreasingZone, monotoneDecreasingZone</span>
<span class="sd">        and one updated count of [-inf,inf] dfdxIntervals as integer</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nonMonotoneZone</span> <span class="o">=</span> <span class="p">[]</span>    
    <span class="n">monotoneIncreasingZone</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">monotoneDecreasingZone</span> <span class="o">=</span> <span class="p">[]</span>
       
    <span class="n">xBoundsLow</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    <span class="n">xBoundsUp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">xBounds</span><span class="p">)</span>
    
    <span class="n">curXBoundsLow</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">mid</span><span class="p">)</span>
    <span class="n">curXBoundsUp</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">mid</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
    
    
    <span class="n">xBoundsLow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curXBoundsLow</span>
    <span class="n">xBoundsUp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">curXBoundsUp</span>

    <span class="n">dfdxLow</span> <span class="o">=</span> <span class="n">dfdx</span><span class="p">(</span><span class="o">*</span><span class="n">xBoundsLow</span><span class="p">)</span>    
    <span class="n">dfdxUp</span> <span class="o">=</span> <span class="n">dfdx</span><span class="p">(</span><span class="o">*</span><span class="n">xBoundsUp</span><span class="p">)</span>
  
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dfdxLow</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="n">monotoneIncreasingZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curXBoundsLow</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dfdxLow</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="n">monotoneDecreasingZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curXBoundsLow</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">nonMonotoneZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curXBoundsLow</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dfdxUp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="n">monotoneIncreasingZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curXBoundsUp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">bool</span><span class="p">(</span><span class="n">dfdxUp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span> <span class="n">monotoneDecreasingZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curXBoundsUp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">nonMonotoneZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curXBoundsUp</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">dfdxUp</span> <span class="o">==</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="s1">&#39;+inf&#39;</span><span class="p">):</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">dfdxLow</span> <span class="o">==</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">,</span> <span class="s1">&#39;+inf&#39;</span><span class="p">):</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">dfdxUp</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">dfdxLow</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">relEpsdFdX</span><span class="p">,</span> <span class="n">absEpsdFdX</span><span class="p">):</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">dfdxUp</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">dfdxLow</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsdFdX</span><span class="p">,</span> <span class="n">absEpsdFdX</span><span class="p">):</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">nonMonotoneZone</span><span class="p">,</span> <span class="n">monotoneIncreasingZone</span><span class="p">,</span> <span class="n">monotoneDecreasingZone</span><span class="p">,</span> <span class="n">l</span>


<span class="k">def</span> <span class="nf">addIntervaltoMonotoneZone</span><span class="p">(</span><span class="n">newInterval</span><span class="p">,</span> <span class="n">monotoneZone</span><span class="p">,</span> <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; adds one or two monotone intervals newInterval to list of other monotone </span>
<span class="sd">    intervals. Function is related to function testIntervalOnMonotony, since if  the</span>
<span class="sd">    lower and upper part of an interval are identified as monoton towards the same direction</span>
<span class="sd">    they are joined and both parts are added to monotoneZone. If monotoneZone contains</span>
<span class="sd">    an interval that has the shares a bound with newInterval they are joined. Intersections</span>
<span class="sd">    should not occur.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        newInterval:         list with interval(s) in mpmath.mpi logic</span>
<span class="sd">        monotoneZone:        list with intervals from mpmath.mpi logic</span>
<span class="sd">        dict_options:        dictionary with variable interval specified tolerances</span>
<span class="sd">                            absolute = absTolX, relative = relTolX</span>
<span class="sd">    </span>
<span class="sd">    Return:</span>
<span class="sd">        monotoneZone:        monotoneZone including newInterval</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">absEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;absTolX&quot;</span><span class="p">]</span>
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span> 
        
    <span class="k">if</span> <span class="n">newInterval</span> <span class="o">!=</span> <span class="p">[]:</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newInterval</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">newInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">newInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">)]</span>
            
        <span class="k">if</span> <span class="n">monotoneZone</span> <span class="o">==</span> <span class="p">[]</span> <span class="p">:</span>
            <span class="n">monotoneZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">removeListInList</span><span class="p">(</span><span class="n">monotoneZone</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">newInterval</span><span class="p">)):</span>
                <span class="n">monotoneZone</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newInterval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
            <span class="k">return</span> <span class="n">joinIntervalSet</span><span class="p">(</span><span class="n">monotoneZone</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">monotoneZone</span>


<span class="k">def</span> <span class="nf">joinIntervalSet</span><span class="p">(</span><span class="n">ivSet</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;joins all intervals in an interval set ivSet that intersec or share the</span>
<span class="sd">    same bound</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        ivSet:              set of intervals in mpmath.mpi logic</span>
<span class="sd">        relEps:             relative tolerance of variable intervals</span>
<span class="sd">        absEps:             absolute tolerance of variable intervals</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        newIvSet:           new set of joint intervals</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">newIvSet</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">noIv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">newIvSet</span><span class="p">)</span> <span class="o">!=</span> <span class="n">noIv</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
            <span class="n">ivSet</span> <span class="o">=</span> <span class="n">newIvSet</span>
            <span class="n">noIv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet</span><span class="p">)</span>
            <span class="n">newIvSet</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ivSet</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet</span><span class="p">)):</span> 
                <span class="k">if</span> <span class="n">iv</span> <span class="o">==</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> 
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">newIvSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">iv</span><span class="p">:</span>
                    <span class="n">newIvSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span> 
                    <span class="n">newIvSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">absEpsX</span><span class="p">):</span> 
                    <span class="n">newIvSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">iv</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">ivIntersection</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">!=</span><span class="p">[]:</span>
                    <span class="n">newIvSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">iv</span><span class="o">.</span><span class="n">a</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">iv</span><span class="o">.</span><span class="n">b</span><span class="p">)))</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ivSet</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                    <span class="k">break</span>
                
        <span class="k">if</span> <span class="n">ivSet</span> <span class="o">!=</span> <span class="p">[]:</span> 
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet</span><span class="p">)):</span>
                <span class="n">newIvSet</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ivSet</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">1</span>
                
    <span class="k">return</span> <span class="n">newIvSet</span>


<span class="k">def</span> <span class="nf">addIntervalToNonMonotoneZone</span><span class="p">(</span><span class="n">newIntervals</span><span class="p">,</span> <span class="n">curIntervals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;add copy of newInterval(s) to already stored ones in list curIntervals</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">newIntervals</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="n">curIntervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">newIntervals</span><span class="p">))</span>  
    

<span class="k">def</span> <span class="nf">checkTolerance</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks if width of intervals is smaller than a given relative tolerance relEpsX</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        interval:           set of intervals in mpmath.mpi-logic</span>
<span class="sd">        relEpsX:             relative x tolerance</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        reducedInterval:    set of intervals with a higher width than absEps</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">reducedInterval</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">relEpsX</span><span class="p">:</span>
                <span class="n">reducedInterval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">relEpsX</span><span class="p">:</span>
                <span class="n">reducedInterval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span> <span class="o">/</span> <span class="nb">abs</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">relEpsX</span><span class="p">:</span>
                <span class="n">reducedInterval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
               
    <span class="k">return</span> <span class="n">reducedInterval</span>


<span class="k">def</span> <span class="nf">reduceNonMonotoneIntervals</span><span class="p">(</span><span class="n">nonMonotoneZone</span><span class="p">,</span> <span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xSymbolic</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> 
                               <span class="n">dict_options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Reduces non monotone intervals by simply calculating function values for</span>
<span class="sd">    interval segments of a discretized variable interval and keeps those segments</span>
<span class="sd">    that intersect with bi. The discretization resolution is defined in dict_options.</span>
<span class="sd">    </span>
<span class="sd">    Args: </span>
<span class="sd">        nonMonotoneZone:    list with non monotone variable intervals</span>
<span class="sd">        reducedIntervals:   lits with reduced non monotone variable intervals</span>
<span class="sd">        fx:                 variable-dependent function in mpmath.mpi logic </span>
<span class="sd">        xSymbolic:          list with symbolic variables in sympy logic</span>
<span class="sd">        i:                  integer with current iteration variable index</span>
<span class="sd">        xBounds:            numpy array with set of variable bounds</span>
<span class="sd">        bi:                 current function residual bounds</span>
<span class="sd">        dict_options:       for function and variable interval tolerances in the used</span>
<span class="sd">                            algorithms and resolution of the discretization</span>

<span class="sd">    Returns:                reduced x-Interval(s) and list of monotone x-intervals</span>
<span class="sd">        </span>
<span class="sd"> &quot;&quot;&quot;</span>   
    
    <span class="n">relEpsX</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;relTolX&quot;</span><span class="p">]</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">dict_options</span><span class="p">[</span><span class="s2">&quot;resolution&quot;</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">curNonMonZone</span> <span class="ow">in</span> <span class="n">nonMonotoneZone</span><span class="p">:</span>
        <span class="n">curInterval</span> <span class="o">=</span> <span class="n">convertIntervalBoundsToFloatValues</span><span class="p">(</span><span class="n">curNonMonZone</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">curInterval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">curInterval</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">resolution</span><span class="p">)</span>
        
        <span class="n">fLowValues</span><span class="p">,</span> <span class="n">fUpValues</span> <span class="o">=</span> <span class="n">getFunctionValuesIntervalsOfXList</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fx</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">fLowValues</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ivIntersection</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">fLowValues</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">fUpValues</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span> <span class="n">bi</span><span class="p">):</span>
                <span class="n">reducedIntervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">reducedIntervals</span> <span class="o">=</span> <span class="n">joinIntervalSet</span><span class="p">(</span><span class="n">reducedIntervals</span><span class="p">,</span> <span class="n">relEpsX</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
                
    <span class="k">return</span> <span class="n">reducedIntervals</span>


<span class="k">def</span> <span class="nf">getFunctionValuesIntervalsOfXList</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">xBounds</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; calculates lower and upper function value bounds for segments that are</span>
<span class="sd">    members of a list and belong to a discretized variable interval.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        x:          numpy list with segments for iteration variable xi</span>
<span class="sd">        f:          x-dependent function in mpmath.mpi logic</span>
<span class="sd">        xBounds:    numpy array with variable bounds in mpmath.mpi.logic</span>
<span class="sd">        i:          current iteration variable index</span>
<span class="sd">    </span>
<span class="sd">    Returns:        list with lower function value bounds within x and upper </span>
<span class="sd">                    function value bounds within x</span>
<span class="sd">                    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">funValuesLow</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">funValuesUp</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">xBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mpi</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">curfunValue</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">xBounds</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">curfunValue</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span> <span class="s1">&#39;+inf&#39;</span> <span class="ow">and</span> <span class="n">curfunValue</span><span class="o">.</span><span class="n">a</span> <span class="o">!=</span><span class="s1">&#39;-inf&#39;</span><span class="p">:</span>
            <span class="n">funValuesLow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">curfunValue</span><span class="o">.</span><span class="n">a</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">curfunValue</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="s1">&#39;+inf&#39;</span><span class="p">:</span> 
            <span class="n">funValuesLow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">funValuesLow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">curfunValue</span><span class="o">.</span><span class="n">b</span> <span class="o">!=</span> <span class="s1">&#39;+inf&#39;</span> <span class="ow">and</span> <span class="n">curfunValue</span><span class="o">.</span><span class="n">b</span> <span class="o">!=</span><span class="s1">&#39;-inf&#39;</span><span class="p">:</span>
            <span class="n">funValuesUp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">curfunValue</span><span class="o">.</span><span class="n">b</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">curfunValue</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="s1">&#39;+inf&#39;</span><span class="p">:</span> 
            <span class="n">funValuesUp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">funValuesUp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">funValuesLow</span><span class="p">,</span> <span class="n">funValuesUp</span>


<span class="k">def</span> <span class="nf">reduceTwoIVSets</span><span class="p">(</span><span class="n">ivSet1</span><span class="p">,</span> <span class="n">ivSet2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;reduces two interval sets to one and keeps only the resulting interval</span>
<span class="sd">    when elements of both intervals intersect. Each element of the longer interval </span>
<span class="sd">    set is compared to the list of the shorter interval set. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        ivSet1:          list 1 with intervals in mpmath.mpi logic</span>
<span class="sd">        ivSet2:          list 2 with intervals in mpmath.mpi logic</span>
<span class="sd">        </span>
<span class="sd">    Return: list with reduced set of intervals</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ivReduced</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet2</span><span class="p">):</span>
        <span class="n">ivLong</span> <span class="o">=</span> <span class="n">ivSet1</span>
        <span class="n">ivShort</span> <span class="o">=</span> <span class="n">ivSet2</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">ivLong</span> <span class="o">=</span> <span class="n">ivSet2</span>
        <span class="n">ivShort</span> <span class="o">=</span> <span class="n">ivSet1</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivLong</span><span class="p">)):</span>
        <span class="n">curIV</span> <span class="o">=</span> <span class="n">compareIntervalToIntervalSet</span><span class="p">(</span><span class="n">ivLong</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ivShort</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curIV</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="n">ivReduced</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curIV</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ivReduced</span>


<span class="k">def</span> <span class="nf">compareIntervalToIntervalSet</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">ivSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;checks if there is an intersection betweeen interval iv and a list of </span>
<span class="sd">    intervals ivSet. If there is one the intersection is returned. </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        iv:         interval in mpmath.mpi logic</span>
<span class="sd">        ivSet:      list with intervals in mpmath.mpi logic</span>
<span class="sd">    </span>
<span class="sd">    Returns:        intersection or empty list if there is no intersection</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ivSet</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">newIV</span> <span class="o">=</span> <span class="n">ivIntersection</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">ivSet</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">newIV</span> <span class="o">!=</span> <span class="p">[]:</span> <span class="k">return</span> <span class="n">newIV</span>
    <span class="k">return</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">checkWidths</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">relEps</span><span class="p">,</span> <span class="n">absEps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns the maximum interval width of a set of intervals X</span>
<span class="sd">     </span>
<span class="sd">        Args: </span>
<span class="sd">            X:            list with set of intervals    </span>

<span class="sd">        Returns:</span>
<span class="sd">            mpmath.mpi    interval of maximum width</span>
<span class="sd">                        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">almostEqual</span> <span class="o">=</span> <span class="kc">False</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
         <span class="k">if</span><span class="p">(</span><span class="n">mpmath</span><span class="o">.</span><span class="n">almosteq</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span> <span class="n">relEps</span><span class="p">,</span> <span class="n">absEps</span><span class="p">)):</span>
             <span class="n">almostEqual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
             
    <span class="k">return</span> <span class="n">almostEqual</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">modOpt</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../background/background.html">Background</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Saskia Bublitz.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>